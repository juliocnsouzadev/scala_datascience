package week6

object Notes {
  val numbers = Vector(12, -10, 1, 9, 8, 5, 0, -7, 87, -99)

  numbers filter (n => n > 0)
  numbers filterNot (n => n > 0)
  numbers partition (n => n > 0)
  numbers takeWhile (n => n > 0)
  numbers dropWhile (n => n > 0)
  numbers span (n => n > 0)

  val names = Vector("Julio", "Rafael", "Wellington", "Carlos", "Marcelo")

  val julio = "Julio"

  names contains julio

  julio filter (c => c.isUpper)

  julio exists (c => c equals 'i')
  julio exists (c => c == 'i')

  julio forall (c => c.isLetter)

  names

  names sorted

  names sorted Ordering.String

  val allNumbers = (Vector(0, 2, 4, 6, 8, 10) ++ Vector(1, 3, 5, 7, 9, 11)) sorted Ordering.Int

  val pairs = (allNumbers reverse) zip julio

  pairs.unzip

  allNumbers sum

  allNumbers product

  allNumbers max

  allNumbers min

  allNumbers filter (n => n % 2 == 0) sum

  allNumbers filter (n => n % 2 != 0) sum

  def isPrime(n: Int): Boolean =
    (2 until n) forall  (n % _ != 0)

  //CONBINATORIAL SEARCH AND FOR-EXPRESSIONS

  val n = 7
  (1 until n) flatMap (i =>
    (1 until i) map (j => (i, j))) filter(pair => isPrime(pair._1 + pair._2))
                                                  
 def scalarProduct(xs: List[Double], ys: List[Double]):Double =
  (for ((x,y) <- xs zip ys ) yield x * y).sum
  
  scalarProduct(List(10,20), List(5,15))
 
                                                   
}